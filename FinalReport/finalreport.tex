\documentclass[10pt,journal,compsoc,draftclsnofoot]{IEEEtran}

\makeatletter    
    \if@compatibility
\renewenvironment{titlepage}
    {%
      \cleardoublepage
      \if@twocolumn
        \@restonecoltrue\onecolumn
      \else
        \@restonecolfalse\newpage
      \fi
      \thispagestyle{empty}%
      %\setcounter{page}\z@
    }%
    {\if@restonecol\twocolumn \else \newpage \fi
    }
\else
\renewenvironment{titlepage}
    {%
      \cleardoublepage
      \if@twocolumn
        \@restonecoltrue\onecolumn
      \else
        \@restonecolfalse\newpage
      \fi
      \thispagestyle{empty}%
      %\setcounter{page}\@ne
    }%
    {\if@restonecol\twocolumn \else \newpage \fi
     \if@twoside\else
       % \setcounter{page}\@ne
     \fi
    }
\fi
\makeatother

% Definition of \subparagraph
\makeatletter
\newcommand\subparagraph{%
  \@startsection{subparagraph}{5}
  {\parindent}
  {3.25ex \@plus 1ex \@minus .2ex}
  {0.75ex plus 0.1ex}
  {\normalfont\normalsize\bfseries}}
\makeatother

\makeatletter
\newcommand\subsubparagraph{%
  \@startsection{subsubparagraph}{6}
  {\parindent}
  {3.25ex \@plus 1ex \@minus .2ex}
  {0.75ex plus 0.1ex}
  {\normalfont\normalsize\bfseries}}
\makeatother

\newcounter{subparagraph}[paragraph]
\newcounter{subsubparagraph}[subparagraph]

\makeatletter
\def\toclevel@subsubparagraph{6}
\makeatother

\usepackage{listings}
\usepackage{color}
\usepackage{titlesec}
\usepackage{float}
\usepackage{hyperref}
\usepackage{array}
\usepackage{tocloft}
\usepackage{lscape}
\usepackage{textcomp}
\usepackage{pgfgantt}
\usepackage{amsmath}
\usepackage{lipsum}
\usepackage{setspace}
\usepackage{pdfpages}

\usepackage{geometry}
\geometry{margin=0.75in}

\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                             
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\begin{document}
\onecolumn

\begin{titlepage}
\null
\vspace{15mm}

\begin{flushleft}
\begin{bfseries}
	\vskip2mm
	\Huge{Final Report for\\ Better Graphics For A Robotics Grasping GUI}\\
	\vspace{15mm}
	\textbf{\huge Shady Robots} \\
	\vskip2mm
	\large{Group 12}
	\vskip5mm
	\Large{Justin Bibler \\
	Matthew Huang \\
	Daniel Goh \\}
\end{bfseries}

\vspace{15mm}
\Large{CS463: Senior Software Engineering Project} \\
\Large{Spring 2017} \\

\vspace{5mm}

\today

\vfill

\begin{normalsize}
{\bf Abstract:}
This document goes over the project's background, requirements, designs used, technology review, weekly team updates, final poster, documentation, useful resources, and project prospect for the team members.

{\bf Keywords:} OpenRAVE, shaders, warm cool shading, silhouettes, shadows, robotic simulation, geometry, visualization, render, ubuntu, vmware, virtualbox
\end{normalsize}
\end{flushleft}

\newpage

\end{titlepage}

\begin{flushleft}

\tableofcontents

\newpage

\section{Introduction}
Better Graphics For A Robotics Grasping GUI was requested by Cindy Grimm.
This project was requested to improve the robotics simulation's (OpenRAVE) graphics, which its visuals are used in a user study that she is involved in.
The team that worked on this project was Shady Robots, which consists of Justin Bibler, Matthew Huang, and Daniel Goh.
Justin Bibler and Matthew Huang were responsible for the technical implementations.
This include implementing warm cool shading, shadows, and silhouettes in OpenRAVE.
Daniel Goh was responsible for the non-technical aspects of the project, which include communication, documentation, and capstone-related deliverables.
Cindy Grimm was our advisor throughout the project, providing supervision and advice throughout the term. 
\newpage

\section{Requirements Document}

\newpage

\include{reqdoc_v1/reqdoc_v1-content}

\section{Requirements Document Update}

\begin{center}
\begin{table}[H]
\caption{Table showing the requirement that is changed (Requirement), what happened to it (Change Details), and comments for the change(Comments).}
\begin{tabular}{ | p{0.3\linewidth} | p{0.3\linewidth} | p{0.3\linewidth} | }
\hline
\textbf{Requirement}  & \textbf{Change Details}  & \textbf{Comments} \\ \hline

Warm Cool Shading. & 
None. & 
Requirement did not change. \\ \hline

Silhouettes. & 
None. & 
Requirement did not change. \\ \hline

Shadows. & 
None. & 
Requirement did not change. \\ \hline

Initial render must be done within 30s. & 
None. & 
Requirement did not change. \\ \hline

Scene must run at a constant 30 fps. & 
Removed. & 
Requirement was not necessary for the client's purposes. \\ \hline

The system will work on an average modern computer. &
None. &
Requirement did not change. \\ \hline

The system will only run one simulation per window. &
None. &
Requirement did not change \\ \hline

The system shall run properly created simulations. &
None. &
This means that the system will always run valid environment files. \\ \hline

System shall be easily maintained and upgraded.
Have well documented and easily testable functions.
Have functions with single, clear purposes. &
None. &
After speaking with Mike Bailey we discovered that testing graphics is primarily done be ensuring that separate computers create the same render. 
Opposed to unit testing which is very difficult and only analyzes fragment positions.
This process can be done by rendering the scene and examining it. 
In our implementations we have minimal amount of new functions.
This is because most of the work done was hacked into the initializations and uses built in coin3d modules. \\ \hline

The system shall continuously re-render the scene until completion of the simulation or software termination. &
None. &
Requirement did not change. \\ \hline

The system shall work on Linux operating systems. &
None. &
Operating systems became limited due to Openrave.
Our current implementation does work on Linux, within Ubuntu 16.04. \\ \hline

Outdated OpenGL libraries will be updated to utilize OpenGL 3.0 libraries. &
None. &
We were unable to directly import new libraries as this was abstracted out from us.
However, we did update the environment that was given to us to Ubuntu 16.04 which utilizes OpenGL 3.0 while rendering. \\ \hline

\end{tabular}
\newline
\label{table:RequirementsDocumentUpdate}
\end{table}
\end{center}

The original Gantt chart was not modified.

\newpage

\section{Design Document}

\newpage

\include{designdoc_v1/designdoc_v1-content}

\section{Design Document Update}

\begin{center}
\begin{table}[H]
\caption{Table showing the design that is changed (Design), what happened to it (Change Details), and comments for the change(Comments).}
\begin{tabular}{ | p{0.2\linewidth} | p{0.7\linewidth} | }
\hline
\textbf{Design}  & \textbf{Change Details} \\ \hline
Warm Cool Shading & 
Warm Cool shading is still done in vertex and fragment shaders, but those shaders are now created by SoShadowGroup.cpp. 
Therefore, the Warm Cool shading code is now in the SoShadowGroup library. 
Additionally, the Warm Cool shaders now adapt to the object's original color. 
This was necessary to prevent bad color mixtures such as blue and orange. 
Further details on how this was done can be found in the design document. \\ \hline
Silhouettes & Silhouettes are now done using the silhouette lines method. 
In other words, the silhouettes are rendered using GL\_LINES instead of polygons. 
This was done to keep consistent silhouette widths throughout all the rendered objects. \\ \hline
CodeXL & Removed since the fps requirement was removed. 
Additionally, CodeXL only works on Windows (our system runs on Ubuntu 16.04) and testing was done better by simply running the system on different machines. \\ \hline
Online Survey Creation & 
The online survey creation is changed to use Qualtrics instead of Google Forms.
Most of the design remain the same, except for some additions that come with Qualtrics' survey features.
The design of the online survey utilized blocks to separate questions across pages. \\ \hline
Data Analysis and Visualization & 
The data analysis and visualization tool is changed to use Qualtrics instead of Google Sheets.
The design of data analysis and visualization remains the same. \\ \hline
\end{tabular}
\newline
\label{table:DesignDocumentUpdate}
\end{table}
\end{center}

\newpage

\section{Tech Review}

\newpage

\include{techreview_v1/techreview_v1-content}

\section{Tech Review Update}

\begin{center}
\begin{table}[H]
\caption{Table showing the technology that is changed (Technology), what happened to it (Change Details), and comments for the change(Comments).}
\begin{tabular}{ | p{0.2\linewidth} | p{0.2\linewidth} | p{0.5\linewidth} | }
\hline
\textbf{Technology}  & \textbf{Change Details}  & \textbf{Comments} \\ \hline

Shading Method & 
Technology did not change (still uses Warm Cool shading), only implementation. & 
As stated in the design doc., now adapts to the object's original color and is now implemented using the SoShadowGroup library. \\ \hline
Silhouettes &
Now uses GL\_LINES method instead of the silhouette edge algorithm. &
The silhouette edge algorithm required direct control over some OpenGL tools (like the view port and the depth buffer) that we did not have access to.
The GL\_LINES method was chosen because it has consistent silhouette widths throughout objects (cel shaded silhouettes did not). \\ \hline
Debugger  &
Went from CodeXL to testing using multiple machines to render the scene. &
Firstly, as stated in the design doc. table, CodeXL only works on Windows while our system runs on Ubuntu 16.04 so we can not even use it.
Secondly, it's easier to test and debug this system by running the simulations on different computers and then examining the scene.
Lastly, the fps requirement was removed in our requirements document so optimization was not a focus. \\ \hline
Survey Platform  &
Platform to run survey was switched from Google Forms to Qualtrics. &
Oregon State University provides Qualtrics license to its students, which allows us to utilize the premium features provided.
This platform allows us to enhance the survey's design and customization. \\ \hline
Data Analysis and Visualization Tool &
Data analysis and visualization tool switched from Google Sheets to Qualtrics' built-in data analysis and visualization tools. &
Qualtrics' built-in features allow direct data analysis and visualization, allowing more efficient data reporting. \\ \hline


\end{tabular}
\newline
\label{table:TechReviewUpdate}
\end{table}
\end{center}

\newpage

\section{Weekly Blog Posts}
\input{githubwiki}

\section{Final Poster}
\vfill
\begin{figure} [h]
  \includegraphics[width=\linewidth]{team12.eps}
  \caption
{ \newline \hspace{\linewidth}
Shady Robots' poster that was used in OSU College of Engineering Undergraduate Engineering Expo 2017}
  \label{fig:poster}
\end{figure}
\vfill
\newpage

\section{Project Documentation}

\subsection{How does it work?}

OpenRave is a program that runs robotic simulations.
However, OpenRave doesn't do everything.
It simply contains the environment (object collisions, etc...) and executes the calculations.
Operations such as scene rendering are offloaded onto plugins; in our case we use the qtcoinrave plugin to render a visual representation of the scene.
Qtcoinrave is an amalgamation of Qt, coin3d, and OpenRave.
Qt is the window creation library, and handles the rendering.
Coin3d is the API that retrieves modules from OpenInventor.
Note, that OpenInventor, as far as we know, is closed source.
We primarily worked with the coin3d API within qtcoinviewer.
The Qt render works by adding objects to a scene graph which is then loaded and rendered by Qt.
The objects are defined within the python environment file and then shaded within qtcoinviewer.
We used coin3d libraries to implement warm cool shading, silhouettes, and shadows.
Each of these are implemented using their own GLSL vertex and fragment shader.
The silhouettes are the only shader that are individually implemented into qtcoinviewer.cpp.
Both the shadows and warm cool shading shaders are generated at run-time using the built in SoShadowGroup class.
We implement multi-rendering by adding two instances of the objects to the scene graph.
Which forces Qt to render multiple times.

\newpage

\subsection{Installation Guide}
\input{installation}

\newpage

\subsection{Running OpenRAVE}

To run OpenRAVE with hanoi simulation:

\begin{lstlisting}
    $ openrave.py --example hanoi --viewer=qtcoin
\end{lstlisting}

To load a specific environment into OpenRAVE:

Go to openrave/src/data on the terminal, with python interpreter:
\begin{lstlisting}
    $ from openravepy import *
    $ env = Environment()
    $ env.SetViewer( 'qtcoin' )	
    $ env.Load( 'hanoi.env.xml' )
\end{lstlisting}

\subsection{Requirements for OpenRAVE}
Ubuntu 16.04 is required to install OpenRAVE with this method.

\section{Resources Used for Project (API documentation)}


\newpage

\section{Lesson Learned from Project}
% What technical information did you learn?
% What non-technical information did you learn?
% What have you learned about the project work?
% What have you learned about project management?
% What have you learned about working in teams?
% If you could do it all over, what would you do differently?

\subsection{Justin Bibler}


\subsection{Matthew Huang}
From a technical perspective, during this project, I learned a lot about how the Coin3d API operates, how Open Inventor modules operate, and how they interact with QT to ultimately render a scene.
Additionally, I learned more about how shaders operate (especially older versions I.E. glsl 1.2) and how multiple shaders interact with each other.
During this project, I was taking the graphical courses offered at OSU (I.E. computer graphics and shaders) so I did have some previous technical knowledge about shaders before I started coding.
What this project specifically taught me about shaders was how many different and unorthodox ways that they could be used.
The environment I was working in was not native OpenGL so many of the areas that I was used to was taken away from me.
I had to use the tools at my disposal (mainly the Coin3d API) to implement the features I was responsible for which was the most difficult part of the project.\par
\vspace{3mm}
When it comes to non-technical information, I learned that research is vitally important when going in to a big team project.
If I had done more research into the environment I would be working in, I could have had a better plan of action which would have saved me a ton of implementation time.
The research I did do, however, assisted me greatly when one of my initial solutions happened to fail.
Knowing multiple ways to implement the same (or similar) feature also gave me a better idea about what was possible in the environment.
As far as project work goes, I learned that it is smart to split up the responsibilities of a big project to individual team mates.
This seemed obvious before (in past class projects), but it was made very apparent during this capstone project.
Splitting up the responsibilities allows every member of the team to do something and it ensures that every member holds each other accountable.
This was especially important for this project since no one could realistically do everything on their own. \par
\vspace{3mm}
For project management, my biggest takeaway that I got from this was that accurate documentation and a consistent work schedule are vitally important to getting a large project done.
The documentation may be annoying to keep up to date, but it is important because it reflects what has been done and what needs to be done.
The work schedule is important because it ensures that consistent progress is being made.
As for my team mates and working with them, I learned team mates are great to bounce ideas off of especially when you are road blocked.
There were multiple times during this project where I was stuck and the only way that I could progress was through consulting my team mates.
Additionally, I learned that team mates are great for moral support.
Whenever I got burnt out, a team mate could step up and take some of the slack while I recovered.
This helped not only my stress, but also my motivation to continue working. \par
\vspace{3mm}
In the end, if I could do this project differently, I would first do more research into the environment I would be working in (since this ultimately was the real challenge).
Doing this would have improved my design document and reduced my implementation time.
Second, I would make sure that I had the initial environment set up and working before winter term.
This way, I could have spent the first couple of weeks coding instead of installing and debugging packages.
Lastly, I would have demoed the features I implemented to the client earlier so she could give me feedback sooner.
This way, I would have been less stressed during the week leading up to the code freeze.
\subsection{Daniel Goh}
Coming into the project with zero graphical technical knowledge, I learned some graphical terminologies and concepts through the group development sessions.
I also learned how to better communicate and condense ideas, both verbally and in written form. 
Through the project assigned to our team, I learned that a project can consist of many small pieces.
The project assigned to the team that I am in, is one of the small piece which focuses on improving a simulation's graphics.
This small piece will be used and be pieced together into a bigger picture.
I have also learned that project management is important to allow a project to reach its end goal.
With that, early coordination of tasks and roles is important to get the project going.
In terms of working in teams, I've learned that constant communication with team members is important.
Due to communication issues early in the project, all of the team members suffered from having to rewrite sections of the technology review document.
I have learned that communicating "what I'm doing", "how I'm doing it" and "what I'm going to do" to the team would allow other team members to be aligned on the same page.
If I could do it all over, I would insist myself to learn more about graphics during the Fall term prior to the development term.
With that knowledge, I would have had the chance to play a more active role in researching the OpenRAVE environment, and work on the graphical implementations.

\newpage

\section{Appendix 1: Essential Code Listings}



\end{flushleft}

\end{document}

