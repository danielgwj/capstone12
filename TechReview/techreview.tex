\documentclass[10pt,journal,compsoc,draftclsnofoot]{IEEEtran}

\usepackage{tocloft}
\usepackage{lscape}
\usepackage{textcomp}
\usepackage{pgfgantt}
\usepackage{geometry}
\geometry{margin=0.75in}

\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}

\begin{filecontents}{techreview.bib}
@misc{userResearch,
 author = {usability.gov},
 title = {User Research Methods},
 url      = {https://www.usability.gov/how-to-and-tools/methods/user-research/index.html}
}

@article{usabilitynet,
 author = {John Brooke},
 title = {SUS - A quick and dirty usability scale},
 url      = {http://www.usabilitynet.org/trump/documents/Suschapt.doc}
}

@misc{google,
 author = {Google},
 title = {Google Terms of Service},
 url      = {https://www.google.com/policies/terms/}
}

@misc{surveymonkey,
 author = {SurveyMonkey},
 title = {SurveyMonkey and IRB Guidelines},
 url      = {http://help.surveymonkey.com/articles/en\_US/kb/How-does-SurveyMonkey-adhere-to-IRB-guidelines}
}

@misc{debugging,
author = {Microsoft},
title = {Standard Debugging Techniques},
url = {https://msdn.microsoft.com/en-us/library/windows/hardware/hh439390(v=vs.85).aspx}
}

@misc{maintainability,
author = {Markus Pizka, Florian Deißenböck},
title = {How to effectively define and measure maintainability},
url = {http://www.itestra.de/fileadmin/Redaktion/Documents/07\_itestra\_define\_and\_measure\_maintainability.pdf}
}

@misc{version,
author = {git},
title = {Getting Started - About Version Control},
url = {https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control}
}

@misc{refactoring,
author = {c2},
title = {What Is Refactoring},
url = {http://wiki.c2.com/?WhatIsRefactoring}
}

@misc{lightmapping,
author = {Alan Baylis},
title = {Lightmapping Tutorial},
url = {http://www.alsprogrammingresource.com/lightmapping\_tutorial.html}
}

@misc{volume,
author = {Josh Beam},
title = {Tutorial - Stenciled Shadow Voumes in OpenGL},
url = {http://joshbeam.com/articles/stenciled\_shadow\_volumes\_in\_opengl/}
}

@misc{shadowMapping,
author = {opengl-tutorial},
title = {Tutorial 16 : Shadow mapping},
url = {http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/}
}
\end{filecontents}

\begin{document}
\onecolumn

\begin{titlepage}
\null
\vspace{20mm}

\begin{flushleft}
\begin{bfseries}
	\vskip2mm
	\Huge{Technology Review for\\ Better Graphics For A Robotics Grasping GUI}\\
	\vspace{30mm}
	\textbf{\huge Shady Robots} \\
	\vskip2mm
	\large{Group 12}
	\vskip5mm
	\Large{Justin Bibler \\
	Matthew Huang \\
	Daniel Goh \\}
\end{bfseries}

\vspace{15mm}
\Large{CS461: Senior Software Engineering Project} \\
\Large{Fall 2016} \\

\vspace{10mm}

\today

\vfill

\begin{normalsize}
{\bf Abstract:}
Our customer is using a simulation to create visuals that are used for online data collection.
This simulation is using outdated libraries which result in outdated graphics.
We, as the supplier, compare and contrast the different technology and methods that will be used during the phase of the project to ensure the project's success.
\end{normalsize}
\end{flushleft}

\end{titlepage}



\section{Overview}
\vspace{3mm}
The technology review document is used to determine the best approach of implementation for the project. 
Clause 2 lists the references made to other documents.
Clause 3 lists each team member's role in the project and accomplishment goals.
Clauses 4 to 6 are the technology review that is carried out by each team member.
Clause 4 reviews the technology to be used to carry out runtime analysis. performance benchmarks, and best practices to implement shadows.
Clause 5 reviews the best practices to implement shaders, best practices to implement silhouettes, and technology to be used to ensure maintainability of the project's source code.
Clause 6 review usability inspection methods, run user interviews, and tools to analyze the respondents data.

\section{Roles and Accomplishment Goals}

\subsection{Justin Bibler}
My roles within this project vary from each other, and are not one cohesive singular responsibility.
I have two responsibilities that have a conclusive end, and a responsibility that is maintained throughout the entire project.
The first of the two conclusive responsibilities that I have is to locate where in the code the rendering is happening.
This responsibility is critically important to the entirety of the group, as without knowledge of the location of the rendering function it is difficult to implement shaders.
Secondly, I will be overseeing the implementation of the shadows.
Shadows help define where 3d objects are within a computer simulation, thus our client requested them to be implemented to improve the current graphics.
Finally, my last responsibility is to assure code maintainability.
This means that once our group has finished with the project our additions to the code will be well documented, commented, and easily understandable.
Making it easy for our shader implementations to be changed and adjusted easily to fit our client's needs.
\indent
Within the "Identification of Rendering loop, Methods of code maintainability, and Shadows" section I compare and contrast three different methods and tools available to conduct and maintain my responsibilities.
How the comparison of methods and tools will be conducted is: I will first explain what the responsibility is and it's relevance to the group and the project.
I will then list a tool or method and how it is used or conducted.
Next, I will list and analyze the benefits and negatives of a tools usage.
At the end of each section I discuss my opinion on the usage of the method.
Finally, after listing all of the available different method and tools I will give my verdict on what will be used.

\subsection{Matthew Huang}

\subsection{Daniel Goh}
My role within Shady Robots is to measure the improvement that is implemented into the simulation.
Usability inspection methods will be a standard of metrics to determine if the project has reached the end goal.
The goal within this document is to compare and contrast the different available usability inspection methods, data collection tools, and analytical and visualization tools.
After reviewing the various tools, a final verdict of the review is presented at the end of each section.

\newpage

section{Identification of Rendering loop, Methods of code maintainability, and Shadows}
\large{By Justin Bibler}

\normalsize
\subsection{Identification of Rendering loop}
Our project requires our group to make new implementations into the existing openrave code.
However, the location of the rendering functions within openrave are not entirely know to our client.
Therefore, the responsibility of locating these functions has been given to our group.
This responsibility is very important to the entirety of the project.
Most of our new implementations into the code will be reliant on the use of shaders;
 if the location of the rendering functions are unknown to us it would be extremely difficult for us to make good shader implementations.
Thus, to identify the location of the rendering functions the three most fitting methods would be: Reading Static Code, debugging, external references, and documentation.

\subsubsection{Reading Static Code}
This is a very basic method in which a programmer simply reads over and reviews static code.
In this case the openrave source code would be read over to identify how the rendering function is working.

Benefits of Reading Static Code:
\begin{itemize}
\item The entire system can be understood at a very low level.
\item Locations of specific functions within the code can be identified.
\item Exact implementation of functions can be understood.
\end{itemize}

Negatives of Reading Static Code:
\begin{itemize}
\item This method can become very time consuming depending on the size and complexity of the code.
\item Code may difficult to read depending on how it is implemented.
\item Inefficient, a programmer will most likely have to flip around multiple source files to figure out how things are working together.
\end{itemize}

\paragraph{Conclusion}
\vspace{3mm}
Reading static code might be too simple of a method to conduct by itself.
It would definitely help me get a good understanding of how the code is function.
However, as mentioned in the negatives of this method it may be too time consuming.
The source code for openrave is quite large, and I have minimal experience working on a project this large scale so it would be difficult for me to jump right in and simply read code.
Perhaps if this method were to be paired with another it could be useful.

\subsubsection{Debugging}
Debugging is a process where a programmer will use tools, and programming methods to locate errors in code.
Many different forms and tools exist to conduct debugging.\cite{debugging}
Thus, I will narrow the scope down to one specific form a debugging: breakpoints, and step through.
Breakpoints stop an executable and breaks into the debugger.
This allows a programmer to analyze the code and execute debugger commands.\cite{debugging}

Benefits of Debugging:
\begin{itemize}
\item Lots of available tools.
\item Lots of available methods.
\item Powerful control over code.
\item Executable within most modern IDEs.
\end{itemize}

Negatives of Debugging
\begin{itemize}
\item Difficult to conduct on large projects.
\item Stepping through code can become time consuming.
\end{itemize}

\paragraph{Conclusion}
\vspace{3mm}
Debugging is a good method that would help me accomplish my goal.
If I were to use a method such as breakpoints and step through code at certain points, it could become a very helpful resource to use.
However, due to the size of the program I am not exactly sure how easy it will be to debug.

\subsubsection{External References, and Documentation}
Much like reading static code this is a very simple and obvious method that can be used to locate the rendering function.
This method is where a programmer will read through the available documentation to understand how the system works.
In this method a programmer will also contact other programmers who are working on the code currently, or have worked on the code in the past.
With the intention of receiving guidance on how the system works.

Benefits of External References, and Documentation:
\begin{itemize}
\item Easy to get answers to specific questions.
\item Documentation gives a good understanding of the entirety of a system.
\end{itemize}

Negatives of External References, and Documentation:
\begin{itemize}
\item There may be no documentation.
\item External sources may not exist.
\item Past programmers may be unresponsive.
\end{itemize}

\paragraph{Conclusion}
\vspace{3mm}
It's quite obvious that this is one of the best methods.
Because I am attempting to find a specific function within the code, referring to the documentation and external sources is a good choice.
Along with this, the GitHub that is being used for openrave has a couple of active users so it would be relatively easy to contact another programmer who is more knowledgeable to assist me.

\subsubsection{Verdict}
My verdict on methods for identifying the rendering function is that all of the proposed methods are useful.
I will most likely begin my search in the documentation then use the knowledge I gained from the documents to traverse through the source code.
This is because as helpful as the documentation will be, it's required of me to read the actual code so I will have an even better understanding of it.
If I am unable to locate the rendering function through documentation and by reading the code.
I will reach out to other programmers within the GitHub group for assistance.
As a last result, I will be using debugging techniques to traverse through the code in attempts to locate the function.

\subsection{Methods of code maintainability}
The goal of creating maintainable code is to increase cost effectiveness.
This means that whenever a new change needs to be made to the system, due to how the code is a designed and constructed this change will take a minimal amount of time.\cite{maintainability}
Maintainability is important to our code, because our client wishes to have the ability to easily change and adjust our implementation of shaders into the system.
Thus our implementations into the code should use methods that allow for an increase in the ability to quickly understand and modify code.
These proposed methods are: Version Control, Refactoring, Documentation, and Commenting.

\subsubsection{Version Control}
Version control has become increasingly easy to maintain with the popularity of version control tools such as GitHub.
Using version control allows for users to make copies of repositories to either use for personnel use or make altercations.
This practices gives protection to the code, such as if programmer losses or makes a devastating alteration to the code.
That programmer doesn't have to worry much, because they know they can pull unmodified working code from the repository.\cite{version}

Benefits of using Version Control:
\begin{itemize}
\item Source code is easily accessible.
\item General tests can be defined to update stable versions of code in a repository.
\item Code is safe to accidental deletion, or introductions of major bugs.
\end{itemize}

Negatives of using Version Control:
\begin{itemize}
\item There aren't really any negatives
\end{itemize}

\paragraph{Conclusion}
\vspace{3mm}
Using version control is a obvious powerful tool.
It essentially protects code from being lost or broken.
If a programmer accidentally introduces a large bug into the system, then with version control it is very easy to step back and pull older versions of the code.
In the case that a programmer accidentally deletes their code, it's easy for them to go back and simply pull it from the repository again.
Using version control most assuredly would help increase code maintainability.

\subsubsection{Refactoring}
Refactoring is a process in which code is altered in a manner such that it does not change how the external behavior of the system works.\cite{refactoring}
In the case of this project, refactoring would be used after our group has created a working implementation of our clients request.
We would go back into our code, and adjust our code so that it might be smaller, more readable, and in most cases reusable.
Such as refactoring repeated code into a singular function that can be used in multiple locations of the code.

Benefits of using Refactoring:
\begin{itemize}
\item Easy to do.
\item Cuts down code size.
\item Reusable functions can be implemented and used in different locations of code.
\item Maximizes runtime.
\end{itemize}

Negatives of using Refactoring:
\begin{itemize}
\item After a lot of refactoring code can become less readable.
\end{itemize}

\paragraph{Conclusion}
\vspace{3mm}
Refactoring is a good method to maximize code, especially when refactoring repeated code into new functions.
If I were to refactor our implementations into the code with the client's desires in mind.
I could most likely make it simple for them to adjust, and reuse functions throughout the program if they desire to change it.

\subsubsection{Documentation, and Commenting}
Documentation and Commenting allows new programmers to quickly get a grasp on the code.
In the case of comments, a programmer is able to quickly understand intentions behind functions and certain operations within the code to get a better understanding of how the system works.
And documentation of the code allows a programmer to have references to many questions related to the code.

Benefits of Documentation, and Commenting:
\begin{itemize}
\item New programmers have references to the what, where, and why of code.
\item Good commenting allows a programmer to get a better understanding of the code while directly reading the code.
\item Programmers have references of how to use functions, either in the comments of a function or in the documentation.
\end{itemize}

Negatives of Documentation, and Commenting:
\begin{itemize}
\item Too much, and useless comments can make code look clustered and sloppy.
\item Writing documents can become time consuming depending on the size of system.
\end{itemize}

\paragraph{Conclusion}
\vspace{3mm}
Early in the document I talked about how I would be using documentation to help find the rendering functions within the openrave code.
Thus, I personally find using documentation very helpful.
I personally would prefer to focus more heavily on documenting our additions outside of the code rather then simply using comments.
This is because documents are simply and easier reference.

\subsubsection{Verdict}
Each of these methods has it's usefulness that I will utilize to keep the system maintainable.
Version control allows our group to make alterations to the code without fear of losing stable versions.
This also allows for our client to come in and make their own alterations later in the future after the project is finished.
In regards to documentation, and commenting.
I will be recording all the changes and additions we make to the source code.
This allows our group, and our client to have easy references to usable functions within the system.
Finally, I will be using refactoring when I see it fit to be used.
Our group is not expecting to make such massive alterations into the existing code that refactoring would have a major impact.
I also do not intend to refactor the currently written openrave code.

\subsection{Shadows}
Shadows are used to help understand where in an object is within a 3d simulation.
However, the current graphics used in openrave do not contain shadows.
So our client has requested that we implement shadows into the current system.
My proposed methods are: Light mapping, Shadow volumes, and Shadow mapping.

\subsubsection{Light mapping}
A light map is simply a texture that contains information about the lighting. 
In most cases a light map is rendered before the program is executed to speed up the programs runtime.
Essentially, this light map is blended with textures that are intended to be lit to give off an illusion of lighting, and shadows.\cite{lightmapping}

Benefits of using Light mapping:
\begin{itemize}
\item Easy to implement.
\item Can be pre-rendered to increase runtime
\end{itemize}

Negatives of using Light mapping:
\begin{itemize}
\item Lighting is not dynamic.
\end{itemize}

\paragraph{Conclusion}
Light mapping seems like a good choice for doing lighting and shading for static objects in openrave.
However, because the simulation contains moving 3d objects it will most likely need more dynamic shadows.

\subsubsection{Shadow Volumes}
This form of shadowing takes advantage of the stencil buffer in openGL.
Essentially, a shadow volume is a volume in space that contains every point in which an object could be shaded.
Objects that collide with the shadow volume should generate shadowing on their surface according to the shadow volume.
This is done by rendering objects shadowed pixels with different stencil values compared to their non-shadow pixels. \cite{volume}

Benefits of Shadow Volumes:
\begin{itemize}
\item Dynamic.
\item Relatively lightweight.
\end{itemize}

Negatives of Shadow Volumes:
\begin{itemize}
\item Doesn't generate the best looking shadows.
\end{itemize}

\paragraph{Conclusion}
\vspace{3mm}
This for of creating shadows seems relatively simple for my skill level.
Along with this it's dynamic, and lightweight which are both good qualities our group is looking for in our shadow implementations.

\subsubsection{Shadow maps}
Shadow mapping is kind of like light mapping.
Shadow mapping works by rendering a scene twice.
In the first render, only the depth of each fragment is computed.
In the second render, the scene is rendered normally.
However, the information computed in the first render is used to calculate whether or not an object has fragments in front of it relative to the light source.
If a fragment has a fragment from the first render blocking it, a shadow should be placed displayed. \cite{shadowMapping}

Benefits of Shadow Mapping:
\begin{itemize}
\item Shadows are dynamic.
\item Shadows will look good because they are fragment based.
\end{itemize}

Negatives of Shadow Mapping:
\begin{itemize}
\item Requires scene to be rendered multiple times.
\item Worse runtime.
\end{itemize}

\paragraph{Conclusion}
\vspace{3mm}
Shadow mapping seems great, it also seems like it would create the best looking shadows for the simulation.
However, shadow mapping would most likely greatly increase the runtime of the program and be detrimental to the FPS.

\subsubsection{Verdict}
I think that the shadow volume implementation would be the best to implement into the system.
This is because it offer acceptable looking dynamic shadows, without sacrificing too much runtime and FPS.
It would be great if we could implement the shadow mapping, but the computers that the simulation will be frequently ran on does not have the best GPU.
Making shadow mapping a bad choice.

\newpage

\section{Technology Review of}
\large{By Matthew Huang}

\subsection{Tech 1}

\subsubsection{Method 1}

\subsubsection{Method 2}

\subsubsection{Method 3}

\subsection{Tech 2}

\subsubsection{Method 1}

\subsubsection{Method 2}

\subsubsection{Method 3}

\subsection{Tech 3}

\subsubsection{Method 1}

\subsubsection{Method 2}

\subsubsection{Method 3}

\newpage


\section{Usability inspection methods, how to carry out the selected inspection method, and the tools to analyze the gathered data}
\large{By Daniel Goh}

\normalsize
\subsection{Usability Inspection Methods}
Usability inspection will be carried out to measure the improvement between the starting and the end phase of the project.
Usability.gov lists multiple usability inspection methods that can be used to determine the usability of an interface.
The three main inspection methods that suits this project scope include: Individual Interviews, Online Surveys, and System Usability Scale (SUS). \cite{userResearch}
This section will be used to review various inspection methods and select one that will best suit this project.

\subsubsection{Individual Interviews \cite{userResearch}}
An individual interview is an inspection method in which a interviewer talks to the participant for 30 minutes to an hour.
During this interview, the interviewer is tasked to gain a deeper understanding of the participants.
This includes taking note of the participant's attitudes, beliefs, desires, and experiences.

Guidelines to conduct individual interviews as defined by usability.gov are as follows:
\begin{itemize}
\item Define the aim of the study and select relevant participants.
\item Prepare interview protocol which includes questions and probes to use during the interview.
\item Create a comfortable interview situation by asking questions in a neutral manner and be attentive for probe queues.
\item Get permission to tape interview session, and have one or more note takers during the interview.
\end{itemize}

Benefits of Individual Interviews:
\begin{itemize}
\item Researchers will be able to gain a better understanding of individual participants.
\item Researchers will be able to observe the participant's body language and facial emotions during the interview.
\item Researchers will be able to receive additional insights that might not have occurred to the interviewer.
\end{itemize}

\subsubsection{Online Surveys \cite{userResearch}} 
An online survey is a form of feedback that is done over the internet.
This inspection method is structured as a questionnaire, and is published online to gather feedback from a broad audience.
The data is then stored within a database, and a survey tool is used to analyze the data.

Guidelines to conduct individual interviews as defined by usability.gov are as follows:
\begin{itemize}
\item Identify purpose of the survey.
\item Determine and select target audience that will best suit the project.
\item Identify methods to collect data and limitations to data collection.
\item Create brief surveys.
\item Provide estimated time to completion up front, and show progress of survey to participants.
\item Mix in open-ended questions with closed questions.
\item Allow participants to choose to answer in-depth questions through a follow-up session.
\end{itemize}

Benefits of Online Surveys:
\begin{itemize}
\item Researchers will be able to reach to a broader audience.
\item Researchers will be able to learn who the users are.
\item Users will be more willing to participate as it would not take up too much time.
\item A wide variety of survey tools are available online.
\item Cost efficient for researchers.
\end{itemize}

\subsubsection{The System Usability Scale ~\cite{userResearch}} 
The System Usability Scale (SUS) is a tool created by John Brooke in 1986.
The SUS method is structured as a ten item questionnaire that requires users to rate individual items with five response options; from Strongly agree to Strongly disagree.

Guidelines to conduct System Usability Scale as defined by usability.gov and UsabilityNet.org are as follows:
\begin{itemize}
\item Participants should not spend time thinking about items for a long time, instead they should record their immediate response. \cite{usabilitynet}
\item The questionnaire are defined and covers the need for support, training, and complexity of system usability.
\item Data gathered through this method needs to be "normalized" to produce a percentile ranking.
\end{itemize}

Benefits of The System Usability Scale:
\begin{itemize}
\item Easy to scale to administer to participants.
\item Study can yield reliable results, even on small sample sizes
\item The System Usability Scale is an industry standard, and is credible in differentiating usable systems from unusable ones.
\end{itemize}

\subsubsection{Verdict}
After reviewing the available usability inspection methods, the \textbf{online survey method} would be a better fit for our project.
By utilizing online surveys, the project would be able to collect more insight from a larger and broader audience.
Individual interviews would not be appropriate as our project does not require an emotional understanding of the participant's thoughts and body language.
The System Usability Scale employs questions that dives too deep into the system, and would introduce scope creep in comparison to the requirements provided by our customer.
Thus, the (BOLD)online survey method will be utilized as a usability inspection method to measure the success of the project.

\newpage

\subsection{How to carry out selected inspection method: Online Surveys}
There are many survey tools available online.
This section reviews the various survey tools that are free to use.
The reviews are done after using the survey tools first-handedly.

\subsubsection{Google Forms}
This section covers the pros and cons of Google's survey tool, Google Forms.

Pros of Google Forms for our project purpose:
\begin{itemize}
\item Allows unlimited questions in a form
\item Collected data are visualized as pie charts
\item Collected data can be exported into Google Spreadsheets (Google's equivalent of Microsoft Excel)
\item Collected data can be exported as a .CSV file to be use with other data analysis tools
\item Allows images and videos to be added into each survey questions without the need to host them externally
\item Allows unlimited respondents to take the survey
\end{itemize}

Cons of Google Forms for our project purpose:
\begin{itemize}
\item As the collected data are stored on Google's remote servers, we are giving Google (and their affiliated partners) "a worldwide license to use, host. store, reproduce, create derivative works, communicate, publish, publicly perform, publicly display and distribute" the content \cite{google}
\end{itemize}

\subsubsection{Survey Monkey}
This section covers the pros and cons of Survey Monkey.

Pros of Survey Monkey for our project purpose:
\begin{itemize}
\item Well known as an online survey tool
\item Contains a variety of different questions types
\item Has a dedicated "SurveyMonkey and IRB Guidelines" under the policies section
\item Provides assistance with IRB approvals by providing "evidence permission to use the SurveyMonkey platform to conduct research" \cite{surveymonkey}
\end{itemize}

Cons of Survey Monkey for our project purpose:
\begin{itemize}
\item Only allows 10 questions
\item Only allows 100 respondents
\item No data export capability
\item No data reporting capability
\end{itemize}

\subsubsection{Typeform}
This section covers the pros and cons of Typeform.

Pros of Typeform for our project purpose:
\begin{itemize}
\item Allows unlimited questions
\item Allows unlimited respondents
\item Supports data export
\item Respondent's input can be piped into other questions (User inputs their name for the first question, and the second question can access their name and call them by name in upcoming questions)
\item Interface is modern and beautifully designed
\end{itemize}

Cons of Typeform for our project purpose:
\begin{itemize}
\item Uses keyboard as main input for survey questions
\end{itemize}

\subsubsection{Verdict}
After reviewing various survey tools, \textbf{Google Forms} comes in as the best choice that fits the selected usability inspection method.
Our survey will not collect sensitive information (e.g. social security numbers, credit card numbers etc.), thus it is safe if Google make the data accessible to the public.
The purpose of the survey (to compare the simulation visuals prior to enhancement and after enhancement) is unrelated to the original research, and does not need to be kept confidential.

\newpage

\subsection{Data analysis tools to analyze and visualize collected data}
Data analysis and visualization tools are used in enterprise situations to allow massive data to be processed into meaningful data.
With the inspection method and survey tools selected, a suitable data analysis and visualization tool will be needed to process the raw data.
As the selected survey tool allows CSV (comma separated value files) to be exported, the review will only include tools that can process CSV files and that are free of charge.
The reviews for data analysis and visualization tools are done after using the applications first-handedly. 

\subsubsection{Google Forms, Google Sheets}
Google has a wide range of applications in their portfolio, and the survey tool selected, Google Forms come with an integrated pie chart visualizer.
However, users will be able to transfer the survey data into Google Sheets for a more complete data analysis environment.

Pros of using Google's visualization for our project purpose:
\begin{itemize}
\item Easily transferable across Google platforms
\item Easily shared across multiple collaborators
\item Simple, light weight and easy to use
\item Work can be done in a web browser
\item Keeps records of previous spreadsheet versions for reverting purposes
\end{itemize}

Cons of using Google's visualization for our project purpose:
\begin{itemize}
\item Limited chart types
\item Google (and their affiliated partners) is given "a worldwide license to use, host. store, reproduce, create derivative works, communicate, publish, publicly perform, publicly display and distribute" the content \cite{google}
\end{itemize}

\subsubsection{Microsoft Excel}
Microsoft Excel is an application that requires a subscription fee (as a part of Office 365) to access.
However, as an Oregon State University student, we have access to use the software with a student license.
Microsoft Excel is the leader of all spreadsheet applications.

Pros of using Microsoft Excel for our project purpose:
\begin{itemize}
\item Easy to create charts from CSV files
\item Contains many chart customization options
\item Allows the user to manipulate and show the data in many different ways through PivotCharts
\end{itemize}

Cons of using Microsoft Excel for our project purpose:
\begin{itemize}
\item History keeping of excel files are not reliable
\item PivotCharts requires user overhead to correctly manipulate
\end{itemize}

\subsubsection{d3.js}
D3.js is a JavaScript library that is used to manipulate documents based on the data that is fed into it.
D3 emphasizes it's output on web standards, and only requires an internet browser to show the visualization of data.

Pros of using D3.js for our project purpose:
\begin{itemize}
\item Contains many beautifully designed templates that can be used
\item Code base is open sourced
\item Can display dynamic visualization on web pages
\item Visualization updates on the fly as data gets updated
\end{itemize}

Cons of using D3.js for our project purpose:
\begin{itemize}
\item Not a thorough data analysis tool, but mainly a data visualization tool
\item Has a steep learning curve to get things running
\end{itemize}

\subsubsection{Verdict}
After reviewing the different data analysis and visualization tools, \textbf{Google Sheets} will be used for data analysis and visualization purposes.
As many of the project documents reside in a collaborative Google Drive, migrating the data analysis portion out from a well constructed ecosystem is not necessary.
With Google Sheets, the spreadsheet can be worked on collaboratively and can be shared with the customer for better transparency on the ongoing data analysis. 

\newpage

\bibliographystyle{IEEEtran}
\bibliography{techreview}

\end{document}



